package Algorithms.Recursion;


import java.util.Arrays;

/**
 * Анаграммы слова длиной N вычисляются следующим способом:
 *
 *  1. Построить анаграммы из последних N - 1 букв слова.
 *  2. Циклически сдвинуть буквы слова на 1 влево.
 *  3. Повторить это N раз. Таким образом, каждая буква побывает на
 *  первом месте и будет скомбинирована с анаграммами всех остальных
 *  букв, что и является решением задачи.
 *
 *  Первый пункт решается рекурсивно, т.е вызывается выше описанная операция,
 *  но уже для N-2, N-3 и т.д букв (т.е для меньшего количества). Когда N
 *  составляет 2, дважды выводится текущая ветвь дерева анаграмм, поскольку
 *  анаграммы слова длиной 2 - это само слово и циклический сдвиг этого слова.
 *  После этого управление передается предыдущей ветви - N-3, она после вывода
 *  всех своих N-2 анаграмм передает управление ветви N-4 и так далее.
 *
 *  Визуализация дерева рекурсии приведена ниже.
 *
 *
 *
 *
 *                                           a    d
 *              a    c                       \   /                       c    d
 *              \   /             b          [a d]          b            \   /
 *              [a c]              \           +           /             [c d]
 *                +                [b d] + a   b   d + [a b]               +
 *                d                /        \  |  /        \               b
 *                |               d         [a b d]         a              |
 *                |                            +                           |
 *     c     d    |------------- |             c             |-------------|     b     c
 *      \   /                    |             |             |                    \   /
 *      [c d] + a --------- [a c d] + b -- (a b c d) -- a + [b c d] --------- d + [b c]
 *                             |               |               |
 *               |-------------|               d               |-------------|
 *               |                             +                             |
 *               |                b         [a c b]         a                |
 *               c                 \        /  |  \        /                 c
 *               +                 [b c] + a   c   b + [a c]                 +
 *             [a d]               /           +           \               [b d]
 *             /   \              c          [a b]          c              /   \
 *            a     d                        /   \                        b     d
 *                                          a     b
 *
 */
public class Anagram {

    private char[] data;

    public void displayAnagrams(String word) {
        data = word.toCharArray();
        doAnagram(word.length());
    }

    private void doAnagram(int newSize) {

        if (newSize == 1) {
            // Это - индикатор вызова doAnagram при newSize = 2.
            // Анаграмма слова длиной 1 - это само слово, перестановки больше не нужны.
            return;
        }

        for (int i = 0; i < newSize; i++) {
            // Строим анаграммы последних N-1 букв текущего слова (или подстроки)
            doAnagram(newSize - 1);

            // Если дошли до конца ветки дерева
            if (newSize == 2) {
                // Выводим (это будет вызвано два раза - текущая позиция + тек. позиция
                // с циклическим сдвигом последних двух букв
                System.out.print(Arrays.toString(data) + " ");
            }

            // Циклически сдвигаем текущую подстроку и продолжаем строить
            // под-анаграммы уже для следующей буквы. А если N == 2, вторая
            // итерация этого цикла выведет вторую из двух возможных перестановок
            // слова из двух букв [A, B] >> [B, A] (сдвиг)
            shift(newSize);
        }
    }

    private void shift(int newSize) {
        int i;
        int position = data.length - newSize;
        char temp = data[position];
        for (i = position + 1; i < data.length; i++) {
            data[i - 1] = data[i];
        }
        data[i - 1] = temp;
    }




}

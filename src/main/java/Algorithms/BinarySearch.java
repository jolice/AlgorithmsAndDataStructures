package Algorithms;

/**
 * Реализации двоичного поиска.
 */
public class BinarySearch {


    /**
     * Выполняет поиск элемента в отсортированном массиве за время O(log(N), где N - длина массива.
     * Алгоритм поиска следующий:
     * <p>
     * Пусть искомый ключ - K, индекс середины текущего диапазона - M, a - искомый массив.
     * На каждой итерации:
     * <p>
     * - Для текущего диапазона вычисляется M сравнивается с K.
     * - если a[M] == K, элемент найден. Возвращается M.
     * - если нет, диапазон поиска сокращается вдвое.
     * <p>
     * Минимально возможная длина диапазона - 1. Пусть это диапазон [A, A],
     * тогда M == A. Если следующая итерация не приводит к успешному завершению
     * поиска и последний возможный кандидат отпадает, следовательно, элемент
     * не присутствует в массиве. Тогда:
     * <p>
     * - Если M > K, upperBound принимает значение A - 1, при этом lowerBound - A.
     * Условие A <= A - 1 - ложно, цикл завершается.
     * <p>
     * - Если M < K, lowerBound принимает значение A + 1, при этом upperBound - A.
     * Аналогично: A + 1 <= A - ложно, цикл завершается.
     * <p>
     * После завершения цикла возвращается значение -1.
     *
     * @param array     массив, в котором будет осуществляться поиск.
     * @param searchKey ключ для поиска
     * @return индекс искомого элемента, или -1, если таковой не присутствует в массиве
     */

    public int binarySearch(int[] array, int searchKey) {

        // индекс нижней границы
        int lowerBound = 0;

        // верхняя граница - длина массива - 1, не длина массива!
        int upperBound = array.length - 1;

        // середина текущего диапазона
        int curIn;


        while (lowerBound <= upperBound) {

            // Вычисляем середину текущего диапазона
            curIn = (lowerBound + upperBound) / 2;


            // Каждый раз проверяем середину диапазона.

            if (array[curIn] == searchKey)
                return curIn; // элемент найден

            else
                // если текущий элемент больше искомого
                if (array[curIn] > searchKey)
                    /*
                    Изменяем диапазон поиска: верхняя грань - текущий индекс - 1,
                    поскольку элемент меньше, чем элемент по текущему индексу,
                    следовательно, элементы больше текущего нас не интересуют.

                    Верхней гранью становится пред. индекс (curIn - 1), поскольку
                    текущий уже проверен выше и он не хранит искомый элемент.
                     */
                    upperBound = curIn - 1;
                else
                    /*
                    Наоборот: если элемент больше или равен текущему,
                    нижней гранью становится текущий, элементы меньше
                    текущего нас не интересуют, т.к искомый больше их.

                    Нижняя грань - curIn + 1, плюс один - потому что текущий
                    индекс уже проверен выше.
                     */
                    lowerBound = curIn + 1;
        }
        return -1;
    }

    /**
     * Рекурсивная версия бинарного поиска - вспомогательный метод
     *
     * @param array     массив, в котором будет осуществляться поиск.
     * @param searchKey ключ для поиска
     * @return индекс искомого элемента, или -1, если таковой не присутствует в массиве
     */

    public int recursiveBinarySearch(int[] array, int searchKey) {
        return recursiveBinarySearch(array, searchKey, 0, array.length - 1);
    }

    /**
     * Рекурсивная версия бинарного поиска - основной метод
     *
     * @param array      массив, в котором будет осуществляться поиск.
     * @param searchKey  ключ для поиска
     * @param lowerBound верхняя граница текущего диапазона
     * @param upperBound нижняя граница текущего диапазона
     * @return индекс искомого элемента, или -1, если таковой не присутствует в массиве
     */

    private int recursiveBinarySearch(int[] array, int searchKey, int lowerBound, int upperBound) {

        if (upperBound < lowerBound)
            return -1;

        int mid = (lowerBound + upperBound) / 2;
        if (array[mid] == searchKey)
            return mid;

        if (searchKey > mid)
            return recursiveBinarySearch(array, searchKey, mid + 1, upperBound);
        else
            return recursiveBinarySearch(array, searchKey, lowerBound, mid - 1);

    }


}

package DataStructures.Array;

import java.util.Arrays;

/**
 * Обертка для массива, поддерживающая различные операции
 */
@SuppressWarnings("ManualArrayCopy")
public class Array {

    private long[] array;
    private int size;

    public Array(int size) {
        this.array = new long[size];
    }

    /**
     * Поиск элемента в массиве (проверка не существование)
     * Линейный поиск
     *
     * @param key искомый элемент
     * @return существует ли такой элемент
     */

    public boolean find(long key) {
        int j;
        for (j = 0; j < size; j++) {
            if (array[j] == key)
                break;
        }
        // если счетчик j не дошел до конца массива, элемент найден
        return j != size;
    }

    /**
     * Вставка элемента в конец массива
     * Предполагается, что в массиве есть свободное место и size < длины массива
     *
     * @param value вставляемое значение
     */

    public void insert(long value) {
        array[size++] = value;
    }

    /**
     * Вставка элемента на произвольную позицию в массиве
     * Предполагается, что pos не превышает size
     * <p>
     * Все элементы, [size - 1, pos] сдвигаются на одну позицию
     * влево. В итоге ячейка pos освобождается, и туда вставляется
     * новый элемент
     *
     * @param value вставляемый элемент
     * @param pos   предпочитаемая позиция вставки
     */

    public void insert(long value, int pos) {
        for (int j = size; j > pos; j--)
            /*
            когда j = pos + 1, элемент, занимающий позицию pos,
            сдвигается на одну позицию вправо. После сдвига выполняется
            j--, т.е j = pos, условие j > pos ложно, цикл завершается,
            и старое значение Array[pos] замещается новым
             */
            array[j] = array[j - 1];
        array[pos] = value;
        size++;
    }

    /**
     * Удаляет элемент из массива. Сперва осуществляется
     * линейный поиск позиции удаляемого элемента, предположим,
     * это позиция N. Затем, все элементы, начиная с N + 1 до S - 1
     * последовательно сдвигаются на одну позицию влево (сперва N + 1,
     * затем N + 2, N + 3 и далее), в итоге замещая удаляемый элемент.
     * <p>
     * Т.е N + 1 замещает удаляемый элемент, N + 2 замещает старую позицию
     * элемента N + 1 (т.е его дубликат), N + 3 замещает предыдущую позицию N + 2
     * и т.д.
     *
     * @param value удаляемый элемент
     * @return был ли элемент удален
     */

    public boolean delete(long value) {
        int j; // позиция удаляемого элемента
        for (j = 0; j < size; j++) {
            if (array[j] == value)
                break;
        }
        // счетчик равен длине массива, перебраны все элементы, удаляемый не найден
        if (j == size)
            return false;
        else
            // сдвиг всех элементов [N + 1] до size - 1 на одну позицию влево
            for (int k = j; k < size - 1; k++)
                array[k] = array[k + 1];

        // удален элемент, уменьшаем размер
        --size;
        return true;
    }


    /**
     * Возвращает копию текущего массива
     *
     * @return копия текущего массива
     */

    public long[] getArray() {
        return Arrays.copyOf(array, size);
    }

    /**
     * Возвращает элемент, расположенный по указанному индексу
     * Предполагается, что index < size
     *
     * @param index индекс элемента
     * @return элемент по индексу
     */

    public long get(int index) {
        return array[index];
    }

    /**
     * Возвращает максимальный элемент массива
     */

    public long getMax() {

        if (size == 0)
            return -1;

        long max = array[0];

        for (int i = 0; i < size; i++)
            if (array[i] > max)
                max = array[i];

        return max;
    }

    /**
     * Возвращает минимальный элемент массива
     */

    public long getMin() {

        if (size == 0)
            return -1;

        long min = array[0];

        for (int i = 0; i < size; i++)
            if (array[i] < min)
                min = array[i];

        return min;
    }

    /**
     * Удаляет максимальный элемент массива
     */

    public void removeMax() {
        delete(getMax());
    }

    /**
     * Удаляет минимальный элемент массива
     */

    public void removeMin() {
        delete(getMin());
    }

    /**
     * Внимание: данный алгоритм неэффективен по времени. Тот же эффект достигается с помощью
     * хеш-таблиц, но за линейное время.
     *
     * Удаляет дубликаты из массива за квадратичное время. Алгоритм следующий:
     *
     * Объявляется счетчик дубликатов D.
     * Зона дубликатов - диапазон ячеек массива [size-duplicates, size)
     *
     * Объявляется счетчик дубликатов D. Затем, каждый элемент, начиная от 0 до зоны дубликатов
     * сравнивается с каждым другим, последующим элементом массива. Пусть это пара I и J.
     * Если I == J, J отправляется в зону дубликатов.
     *
     * Чтобы поместить элемент в зону дубликатов, нужно увеличить счетчик дубликатов и поместить
     * элемент на позицию P, равную size - duplicates, т.е в начало зоны дубликатов. При этом
     * элемент на позиции P нужно разместить на позиции J, чтобы не потерять. (Т.е обменять элементы
     * P и J местами). При этом, нужно учесть, что на позицию J может прийти дубликат для текущего
     * проверяемого элемента, поэтому нужно уменьшить счетчик j, чтобы еще раз проверить только что
     * пришедший элемент.
     *
     * Если этого не сделать, дубликат может остаться в массиве. если, скажем,
     * текущий проверямый элемент находится на позиции I, а дубликат - на позиции I + 2, и при расширении
     * зоны дубликатов на позицию I + 2 пришел дубликат, и сравнения продолжились уже с позиции I + 3,
     * то при текущем элементе I + 2 элемент I не будет учтен, т.е останутся дубликаты на позициях I и I + 2).
     *
     * @return количество дубликатов
     */


    public int removeDuplicates() {
        int duplicates = 0;
        for (int i = 0; i < size - duplicates; i++) {
            for (int j = i + 1; j < size - duplicates; j++) {
                if (array[i] == array[j]) {
                    int tIndex = size - (++duplicates);
                    long t = array[j];
                    array[j] = array[tIndex];
                    array[tIndex] = t;
                    j--;
                }
            }
        }
        long[] newArray = new long[size - duplicates];
        for (int i = 0; i < newArray.length; i++)
            newArray[i] = array[i];
        this.array = newArray;
        this.size = newArray.length;
        return duplicates;
    }

    public int getSize() {
        return size;
    }
}

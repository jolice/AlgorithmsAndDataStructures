package DataStructures.Array;

import Algorithms.BinarySearch;


import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.Arrays;
import java.util.function.UnaryOperator;

/**
 * Представляет отсортированный массив.
 * Операция поиска для отсортированного массива инкапсулирована в
 * отдельный класс.
 *
 * @see BinarySearch
 */

public class OrderedArray {


    private BinarySearch binarySearch;
    private int[] array;
    private int size;

    public OrderedArray(int size) {
        this.array = new int[size];
        this.binarySearch = new BinarySearch();
    }

    /**
     * Вставляет элемент в отсортированный массив.
     * <p>
     * Перебираем массив с конца, начиная с N. Пока вставляемый элемент
     * меньше элемента с индексом N-1 (предыдущего), сдвигаем элемент с
     * индексом N-1 на одну позицию вправо. На каждой N-1 позиции после сдвига будем
     * иметь дубликат элемента, который перезаписываем следущим при сдвиге.
     * Если элемент N-1 меньше или равен исходному, место для вставки найдено -
     * это позиция N.
     * <p>
     * Пример: [1, 2, 3, 5, 7, 0, 0, 0, 0, 0], вставляемй элемент - 4.
     * <p>
     * Пусть индекс, куда должен быть вставлен элемент - I. Для этого
     * массива I = 3. Элементы будут сдвигаться вправо до тех пор,
     * пока I не станет равным 3. При I = 3 условие Array[2] > 4 - ложно,
     * цикл прерывается, вставляемое значение размещается по индексу I.
     *
     * @param element вставляемый элемент.
     */

    public void add(int element) {
        int i;
        for (i = size; i > 0 && array[i - 1] > element; i--)
            array[i] = array[i - 1];
        array[i] = element;
        size++;
    }

    /**
     * Удаляет элемент из отсортированного массива
     * <p>
     * Для оптимизации используется двоичный поиск позиции
     * удаляемого элемента, пусть это индекс K. Затем, все
     * элементы массива, начиная с K + 1 до S (длина массива)
     * сдвигаются на единицу влево, в итоге замещая удаляемый элемент
     *
     * @param element удаляемый элемент
     * @return был ли удален элемент (если не найден, false)
     */

    public boolean delete(int element) {

        int index = binarySearch.binarySearch(getArray(), element);

        if (index == -1)
            return false;

        for (int i = index; i < size - 1; i++)
            array[i] = array[i + 1];
        size--;
        return true;
    }

    /**
     * Возвращает копию текущего массива
     *
     * @return копия текущего массива
     */

    public int[] getArray() {
        return Arrays.copyOf(array, size);
    }

    /**
     * Сливает текущий массив с новым. Предполагается, что
     * новый массив отсортирован. Алгоритм следующий:
     * <p>
     * Для обоих массивов создаются счетчики i и j, равные 0.
     * Создается счетчик X для результирующего массива.
     * <p>
     * Будем считать элемент с индексом I обработанным, если I <= i или I <= j
     * (в зависимости от массива).
     * <p>
     * Будем называть элемент с индексом I текущим, если I == i или I == j
     * (в зависимости от массива).
     * <p>
     * Сперва пройдем по обоим массивам и на каждом шаге будем вычислять наименьший элемент
     * из двух массивов среди необработанных (назовем его M).
     * Для этого будем на каждом шаге сравнивать текущие элементы из обоих массивов.
     * <p>
     * Если текущий элемент из массива А меньше текущего элемента из массива Б, то он наименьший
     * из всех необработанных, поскольку он меньше всех расположенных выше элементов в своем массиве
     * и меньше всех вышестоящих во втором.
     * <p>
     * Размещаем M в результирующем массиве и увеличиваем счетчик обработки для массива, откуда был
     * извлечен M.
     * <p>
     * Очевидно, что каждый последующий M будет не меньше предыдущего, потому что на момент извлечения
     * предыдущего следующий находился во множестве необработанных, следовательно, поскольку предыдущий
     * являлся наименьшим среди необработанных, он был не больше последующего.
     * <p>
     * Цикл прерывается, как только один из массивов полностью обрабатывается. Поскольку последний обработанный
     * элемент меньше всех элементов во втором массиве, то все элементы второго массива больше максимального
     * элемента результирующего массива. Следовательно, для получения результата достаточно последовательно
     * вставить элементы из оставшегося массива в результирующий.
     *
     * @param array отсортированный массив
     */

    public void merge(int[] array) {

        int[] srcArray = getArray();
        int[] resultArray = new int[size + array.length];

        int i = 0;
        int j = 0;
        int x = 0;

        // Вычисляем наименьший элемент из двух массивов, пока оба массива не обработаны
        while (i < srcArray.length && j < array.length)
            resultArray[x++] = srcArray[i] < array[j] ?
                    // увеличиваем счетчики - обрабатываем элемент
                    srcArray[i++] : array[j++];

        // Если в первом массиве остались элементы, вставляем в результирующий
        while (i < srcArray.length)
            resultArray[x++] = srcArray[i++];

        // Если во втором массиве остались элементы, вставляем в результирующий
        while (j < array.length)
            resultArray[x++] = array[j++];

        this.array = resultArray;
        this.size = resultArray.length;
    }


}
